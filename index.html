<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Client Questionnaire</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css" />
  <style>
    .hidden { display: none; }
    .section-title {
      margin-top: 2rem;
      font-weight: bold;
      font-size: 1.3rem;
      border-bottom: 1px solid #ccc;
      padding-bottom: 5px;
    }
    .help-text a {
      color: var(--primary);
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <main class="container">
    <h1>Client Questionnaire</h1>
    <form id="questionnaireForm" enctype="multipart/form-data">
      <div id="questionContainer"></div>

      <div id="agreementSection" style="max-height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 1rem; margin: 2rem 0;"></div>
      <label>
        <input type="checkbox" id="agreeCheckbox" disabled required />
        I agree to the terms above
      </label>

      <button type="submit" class="contrast">Submit</button>
    </form>
  </main>

  <script>
    async function loadQuestions() {
      const res = await fetch('/questions.json');
      const questions = await res.json();

      const container = document.getElementById('questionContainer');
      const groupMap = {};

      questions.forEach(q => {
        if (q.group && q.trigger) {
          if (!groupMap[q.group]) groupMap[q.group] = [];
          groupMap[q.group].push(q);
        }
      });

      questions.forEach(q => {
        if (q.trigger) return;

        const wrapper = createQuestionElement(q);
        container.appendChild(wrapper);

        // Append sub-questions inline
        if (groupMap[q.name]) {
          groupMap[q.name].forEach(subQ => {
            const subWrapper = createQuestionElement(subQ);
            subWrapper.classList.add('hidden');
            container.appendChild(subWrapper);
          });
        }
      });
    }

    function createQuestionElement(q) {
      const wrapper = document.createElement('div');
      wrapper.dataset.group = q.group || '';
      wrapper.dataset.trigger = q.trigger || '';
      wrapper.className = q.trigger ? 'hidden' : '';

      const label = document.createElement('label');
      label.innerHTML = q.label;

      if (q.help) {
        const help = document.createElement('small');
        help.className = 'help-text';
        help.innerHTML = q.help;
        label.appendChild(document.createElement('br'));
        label.appendChild(help);
      }

      let input;

      if (q.type === 'textarea') {
        input = document.createElement('textarea');
      } else if (q.type === 'file') {
        input = document.createElement('input');
        input.type = 'file';
        if (q.multiple) input.multiple = true;
      } else if (q.type === 'dropdown') {
        input = document.createElement('select');
        input.name = q.name;
        input.required = q.required;

        const defaultOption = document.createElement('option');
        defaultOption.textContent = '-- Select an option --';
        defaultOption.value = '';
        input.appendChild(defaultOption);

        q.options.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt;
          option.textContent = opt;
          input.appendChild(option);
        });
      } else if (q.type === 'checkbox' || q.type === 'radio') {
        wrapper.appendChild(label);
        q.options.forEach(opt => {
          const option = document.createElement('label');
          const check = document.createElement('input');
          check.type = q.type;
          check.name = q.name;
          check.value = opt;
          if (q.required) check.required = true;
          option.appendChild(check);
          option.append(` ${opt}`);
          wrapper.appendChild(option);
        });
        return wrapper;
      } else {
        input = document.createElement('input');
        input.type = 'text';
      }

      input.name = q.name;
      if (q.required) input.required = true;
      label.appendChild(input);
      wrapper.appendChild(label);

      return wrapper;
    }

    async function loadAgreement() {
      const res = await fetch('/agreement.txt');
      const text = await res.text();
      const section = document.getElementById('agreementSection');
      section.innerHTML = text;

      section.addEventListener('scroll', () => {
        if (section.scrollTop + section.clientHeight >= section.scrollHeight - 10) {
          document.getElementById('agreeCheckbox').disabled = false;
        }
      });
    }

    function handleTriggers() {
      document.getElementById('questionnaireForm').addEventListener('change', (e) => {
        const all = document.querySelectorAll('[data-trigger]');
        all.forEach(el => {
          const [group, triggerVal] = el.dataset.trigger.split(':');
          const triggerInput = document.querySelector(`[name="${group}"]`);
          if (!triggerInput) return;

          let val = '';
          if (triggerInput.type === 'radio' || triggerInput.type === 'checkbox') {
            const checked = document.querySelector(`[name="${group}"]:checked`);
            val = checked ? checked.value : '';
          } else {
            val = triggerInput.value;
          }

          if (val === triggerVal) {
            el.classList.remove('hidden');
          } else {
            el.classList.add('hidden');
          }
        });
      });
    }

    document.getElementById('questionnaireForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      const formData = new FormData(e.target);
      const res = await fetch('/submit', {
        method: 'POST',
        body: formData,
      });

      if (res.ok) {
        window.location.href = '/success.html';
      } else {
        alert('Something went wrong.');
      }
    });

    loadQuestions();
    loadAgreement();
    handleTriggers();
  </script>
</body>
</html>
